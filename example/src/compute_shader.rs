// File automatically generated by build.rs.
// Changes made to this file will not be saved.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, encase :: ShaderType)]
pub struct Uniforms {
    pub color_rgb: glam::Vec3,
}
#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct OverrideConstants {}
impl OverrideConstants {
    pub fn constants(&self) -> std::collections::HashMap<String, f64> {
        [].into_iter().filter_map(|a| a).collect()
    }
}
#[derive(Debug)]
pub struct BindGroupLayout0 {
    device: std::sync::Arc<wgpu::Device>,
    layout: wgpu::BindGroupLayout,
}
impl std::ops::Deref for BindGroupLayout0 {
    type Target = wgpu::BindGroupLayout;
    fn deref(&self) -> &Self::Target {
        &self.layout
    }
}
pub struct BindGroup0(wgpu::BindGroup);
impl std::ops::Deref for BindGroup0 {
    type Target = wgpu::BindGroup;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl BindGroup0 {
    pub fn set(&self, pass: &mut wgpu::RenderPass) {
        pass.set_bind_group(0u32, self, &[]);
    }
    pub fn set_compute(&self, pass: &mut wgpu::ComputePass) {
        pass.set_bind_group(0u32, self, &[]);
    }
}
#[bon::bon]
impl BindGroupLayout0 {
    pub fn new(device: std::sync::Arc<wgpu::Device>) -> Self {
        let layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            label: None,
            entries: &[wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::COMPUTE,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Storage { read_only: false },
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            }],
        });
        Self { device, layout }
    }
    # [builder (finish_fn = create)]
    pub fn bind_group(&self, uniforms: wgpu::BufferBinding<'_>) -> BindGroup0 {
        let bind_group = self.device.create_bind_group(&wgpu::BindGroupDescriptor {
            layout: &self.layout,
            entries: &[wgpu::BindGroupEntry {
                binding: 0,
                resource: wgpu::BindingResource::Buffer(uniforms),
            }],
            label: None,
        });
        BindGroup0(bind_group)
    }
}
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub enum FragmentEntry {}
impl FragmentEntry {
    pub fn entry_point_and_targets(&self) -> (&'static str, &[Option<wgpu::ColorTargetState>]) {
        match self {
            _ => unreachable!(),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
struct PipelineLayoutKey {}
pub struct Shader {
    device: std::sync::Arc<wgpu::Device>,
    shader_module: std::sync::Arc<wgpu::ShaderModule>,
    pipeline_layout_cache: std::sync::Mutex<
        std::collections::HashMap<PipelineLayoutKey, std::sync::Arc<PipelineLayout>>,
    >,
}
impl std::ops::Deref for Shader {
    type Target = wgpu::ShaderModule;
    fn deref(&self) -> &Self::Target {
        &self.shader_module
    }
}
#[bon::bon]
impl Shader {
    pub const SOURCE : & 'static str = "struct Uniforms {\n    color_rgb: vec3<f32>,\n}\n\n@group(0) @binding(0) \nvar<storage, read_write> uniforms: Uniforms;\n\n@compute @workgroup_size(1, 1, 1) \nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    if (global_id.x == 0u) {\n        uniforms.color_rgb = vec3(1f);\n        return;\n    } else {\n        return;\n    }\n}\n" ;
    pub fn new(device: std::sync::Arc<wgpu::Device>) -> Self {
        let shader_module = device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: None,
            source: wgpu::ShaderSource::Wgsl(std::borrow::Cow::Borrowed(Self::SOURCE)),
        });
        let shader_module = std::sync::Arc::new(shader_module);
        Self {
            device,
            shader_module,
            pipeline_layout_cache: Default::default(),
        }
    }
    fn create_pipeline_layout(&self, PipelineLayoutKey {}: PipelineLayoutKey) -> PipelineLayout {
        let device = self.device.clone();
        let bind_group_layouts = (BindGroupLayout0::new(device.clone()),);
        let layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: None,
            bind_group_layouts: &[&bind_group_layouts.0],
            push_constant_ranges: &[],
        });
        let shader_module = self.shader_module.clone();
        PipelineLayout::new(device, shader_module, layout, bind_group_layouts)
    }
    # [builder (finish_fn = get)]
    pub fn pipeline_layout(&self) -> std::sync::Arc<PipelineLayout> {
        let key = PipelineLayoutKey {};
        self.pipeline_layout_cache
            .lock()
            .unwrap()
            .entry(key)
            .or_insert_with_key(|key| std::sync::Arc::new(self.create_pipeline_layout(key.clone())))
            .clone()
    }
}
pub struct PipelineLayout {
    device: std::sync::Arc<wgpu::Device>,
    shader_module: std::sync::Arc<wgpu::ShaderModule>,
    layout: wgpu::PipelineLayout,
    bind_group_layouts: (BindGroupLayout0,),
    main_pipelines: std::sync::Mutex<
        std::collections::HashMap<PipelineKey_main, std::sync::Arc<wgpu::ComputePipeline>>,
    >,
}
impl std::ops::Deref for PipelineLayout {
    type Target = wgpu::PipelineLayout;
    fn deref(&self) -> &Self::Target {
        &self.layout
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
struct PipelineKey_main {
    overrides: OverrideConstants,
}
#[bon::bon]
impl PipelineLayout {
    pub fn new(
        device: std::sync::Arc<wgpu::Device>,
        shader_module: std::sync::Arc<wgpu::ShaderModule>,
        layout: wgpu::PipelineLayout,
        bind_group_layouts: (BindGroupLayout0,),
    ) -> Self {
        Self {
            device,
            shader_module,
            layout,
            bind_group_layouts,
            main_pipelines: Default::default(),
        }
    }
    pub fn bind_group_layouts(&self) -> &(BindGroupLayout0,) {
        &self.bind_group_layouts
    }
    fn main_from_key(
        &self,
        PipelineKey_main { overrides }: PipelineKey_main,
        cache: Option<&wgpu::PipelineCache>,
    ) -> wgpu::ComputePipeline {
        let device = &self.device;
        let module = &self.shader_module;
        let constants = overrides.constants();
        let compilation_options = wgpu::PipelineCompilationOptions {
            constants: &constants,
            ..Default::default()
        };
        device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
            label: None,
            layout: Some(&self.layout),
            module,
            entry_point: "main",
            compilation_options,
            cache,
        })
    }
    # [builder (finish_fn = get)]
    pub fn main_pipeline(
        &self,
        #[builder(default)] overrides: OverrideConstants,
        cache: Option<&wgpu::PipelineCache>,
    ) -> std::sync::Arc<wgpu::ComputePipeline> {
        let key = PipelineKey_main { overrides };
        self.main_pipelines
            .lock()
            .unwrap()
            .entry(key)
            .or_insert_with_key(|key| std::sync::Arc::new(self.main_from_key(key.clone(), cache)))
            .clone()
    }
}
